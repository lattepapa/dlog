---
title: "동적 프로그래밍"
category: algorithm
path: /algorithm/algorithm20
date: 2021-01-11 13:54:00
---

동적 프로그래밍(dynamic programming)은 문제를 부분 문제들로 쪼개는 해결방법이다. 이때, 이미 계산된 결과는 메모리에 저장하여 동일 문제 해결에 언제든지 활용될 수 있도록 하여 시간복잡도를 크게 개선하는 것이 핵심이다. 이때 문제들의 해결 복잡도를 경감시켜줄 최적 해결책이 존재한다면 그러한 최적 부분구조를 활용한다. 예를 들어 차를 타고 도시들을 여행하기 위한 최단 경로를 찾는다고 가정할 때, 서울 ~ 부산의 최단 경로가 대구 ~ 밀양 구간을 반드시 거치는 경우, 대구에서 부산까지의 최단 경로는 반드시 밀양을 거칠 것이다.  
한편, 이러한 동적 프로그래밍의 특성을 반대로 생각해보면, 최적 부분 구조가 존재하면서 중복 부분 문제들이 존재하는 경우에만 사용할 수 있다는 결론에 다다른다.

### 중복 부분문제

중복 부분문제들은 해시 테이블, 배열, 또는 행렬에 저장된 해결책을 여러번 사용하여 해결하도록 한다. 이러한 방식을 **메모이제이션**(memoization)이라고 한다. 피보나치 수열이 이러한 메모이제이션, 즉, 중복 부분문제 재활용의 대표적인 예이다.

```jsx
function fibonacci(n) {
  // 메모이제이션을 위한 빈 해시테이블 생성
  let memo = {};
  if (n <= 1) return n;

  // highlight-start
  // 메모이제이션 활용
  if (memo[n]) return memo[n];
  // highlight-end

  // highlight-start
  // 재귀를 호출하면서 메모이제이션에 추가되도록 한다
  return (memo[n] = fibonacci(n - 1) + fibonacci(n - 2));
  // highlight-end
}
```

<br />

### 최적 부분구조

#### 걸음 수를 채우는 방법(조합의 수)

목표지점까지 $n$걸음 거리가 남았다고 가정하자. 1걸음 또는 2걸음 또는 3걸음의 걸음 수를 조합할 수 있다고 할 때, 만약 $n = 4$라면 목표지점에 도달할 수 있는 조합은 다음과 같다.

1. 1걸음, 1걸음, 1걸음, 1걸음씩 걷는다.
2. 1걸음, 1걸음, 2걸음씩 걷는다.
3. 1걸음, 3걸음씩 걷는다.
4. 2걸음, 2걸음씩 걷는다.

이러한 조합의 수는 다음과 같이 생각할 수 있다. 아래는 단순히 재귀 호출을 구현하여 $O(3^n)$의 시간복잡도를 보일 때보다 훨씬 개선된, $O(n)$의 시간복잡도를 만족한다.

```jsx{numberLines: true}
function stepDP(step) {
  let memo = {};

  if (step < 0) return 0;
  if (step === 0) return 1;

  if (memo[step]) return memo[step];
  else {
    // highlight-start
    // 1걸음 또는 2걸음 또는 3걸음의 3가지 경우로 조합한다
    memo[step] = stepDP(step - 1) + stepDP(step - 2) + stepDP(step - 3);
    // highlight-end
    return memo[step];
  }
}

stepDP(4); // 7 -- {1: 1, 2: 2, 3: 4, 4: 7}
stepDP(12); // 927 -- {1: 1, 2: 2, 3: 4, 4: 7, .... , 12: 927}
```

<br />

#### 배낭 문제(knapsack problem)

다양한 무게와 값어치를 지니는 $n$개의 항목이 주어졌다고 가정할 때, 최대 $w$의 무게를 담을 수 있는 배낭에 해당 항목들을 집어넣되 배낭에 담긴 가치의 합이 최대가 되도록 한다.  
이 문제에서 최적 부분구조를 생각하면, 항목이 최적 부분집합에 포함되거나 포함되지 않는 경우로 분기된다. 따라서 항목들로부터 얻을 수 있는 최대 가치는 1) $n - 1$개의 항목에서 이미 최대 가치를 달성할 경우, 또는 2) 1)의 경우에 $n$번째 항목까지도 더할 수 있을 때 최대 가치를 달성할 경우이다.  
만약 배낭의 최대 허용 무게가 2이고 무게가 1인 항목 3개가 각각 [10, 20, 30]의 값어치를 갖는 경우를 가정한다면 다음과 같은 형태로 배낭에 항목을 담는 경우의 수들을 재귀 트리로 그릴 수 있다.

![dp](https://user-images.githubusercontent.com/67884699/104421109-39fd9780-55be-11eb-9790-5c14b4f29514.jpg)

즉, 최적 부분집합의 범위 안에서 **$n-1$번째 항목까지 최대가치에 도달한 경우와 $n$번째 항목까지 더하여 최대가치에 도달한 경우 중 큰 경우**들을 메모이제이션에 저장하여 재귀 호출에서의 시간복잡도 절약을 수행함으로서 이 문제를 해결한다. 이러한 방식에 의해 시간복잡도와 공간복잡도는 모두 $O(n*배낭무게한도)$을 만족한다.

```jsx{numberLines: true}
function knapsackDP(i, weights, values, limit, memo) {
  // 최대 값어치를 담을 결과변수
  let result = 0;

  // 각 부분집합에서 참고할 해시테이블
  if (memo[`${i}번 항목까지 ${limit}kg 안에 담을 수 있는 최대 값어치`])
    return memo[`${i}번 항목까지 ${limit}kg 안에 담을 수 있는 최대 값어치`];

  // 기저 조건
  if (i <= -1 || limit <= 0) result = 0;
  // 항목이 최적 부분집합의 범위를 벗어난다면,
  // 최적 부분집합의 범위에 이를 때까지 항목을 찾아낸다
  else if (weights[i] > limit)
    result = knapsackDP(i - 1, weights, values, limit, memo);
  // highlight-start
  // 항목의 최적 부분집합의 범위에 존재한다면
  // n-1번째까지 최대가치에 도달한 경우와 n번째까지 포함하여 최대가치에 도달한 경우 중
  // 큰 값을 result에 담는다. 이러한 비교를 limit이 0이 될 때까지 재귀적으로 반복한다.
  else {
    let current = knapsackDP(i - 1, weights, values, limit, memo);
    let currentPlus =
      values[i] + knapsackDP(i - 1, weights, values, limit - weights[i], memo);

    result = Math.max(current, currentPlus);
  }
  // highlight-end

  memo[`${i}번 항목까지 ${limit}kg 안에 담을 수 있는 최대 값어치`] = result;
  return result;
}

let weights = [1, 2, 4, 2, 5],
  values = [5, 3, 5, 3, 2],
  i = weights.length - 1,
  limit = 10,
  memo = {};
knapsackDP(i, weights, values, limit, memo); // 16
/*
{
  0번 항목까지 1kg 안에 담을 수 있는 최대 값어치: 5,
  0번 항목까지 2kg 안에 담을 수 있는 최대 값어치: 5,
  0번 항목까지 3kg 안에 담을 수 있는 최대 값어치: 5,
  0번 항목까지 4kg 안에 담을 수 있는 최대 값어치: 5,
  0번 항목까지 5kg 안에 담을 수 있는 최대 값어치: 5,
  0번 항목까지 6kg 안에 담을 수 있는 최대 값어치: 5,
  0번 항목까지 8kg 안에 담을 수 있는 최대 값어치: 5,
  0번 항목까지 10kg 안에 담을 수 있는 최대 값어치: 5,
  1번 항목까지 1kg 안에 담을 수 있는 최대 값어치: 5,
  1번 항목까지 3kg 안에 담을 수 있는 최대 값어치: 8,
  1번 항목까지 4kg 안에 담을 수 있는 최대 값어치: 8,
  1번 항목까지 5kg 안에 담을 수 있는 최대 값어치: 8,
  1번 항목까지 6kg 안에 담을 수 있는 최대 값어치: 8,
  1번 항목까지 8kg 안에 담을 수 있는 최대 값어치: 8,
  1번 항목까지 10kg 안에 담을 수 있는 최대 값어치: 8,
  2번 항목까지 3kg 안에 담을 수 있는 최대 값어치: 8,
  2번 항목까지 5kg 안에 담을 수 있는 최대 값어치: 10,
  2번 항목까지 8kg 안에 담을 수 있는 최대 값어치: 13,
  2번 항목까지 10kg 안에 담을 수 있는 최대 값어치: 13,
  3번 항목까지 5kg 안에 담을 수 있는 최대 값어치: 11,
  3번 항목까지 10kg 안에 담을 수 있는 최대 값어치: 16,
  4번 항목까지 10kg 안에 담을 수 있는 최대 값어치: 16,
  -1번 항목까지 0kg 안에 담을 수 있는 최대 값어치: 0,
  ...,
  -1번 항목까지 10kg 안에 담을 수 있는 최대 값어치: 0,
}
*/
```

<br />
<br />
<br />
<br />

<text style="color:gray">_\*참고: "자바스크립트로 하는 자료 구조와 알고리즘"(배세민님, 에이콘)_</text>
