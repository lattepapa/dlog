---
title: "알고리즘 증명"
category: algorithm
path: /algorithm/algorithm24
date: 2021-01-15 15:29:00
---

### 귀납법(Proof by Induction)

#### 귀납법 단계

1\. **단계 나누기** : 증명하고자 하는 사실을 여러 단계로 쪼갠다.  
2\. **첫 단계 증명** : 나눠진 여러 단계들 가운데 첫 단계에서 증명하고 싶은 내용이 성립함을 보인다.  
3\. **귀납 증명** : 첫 단계가 성립한다면 다음 단계도 성립함을 보인다.

#### 귀납법 예시

아래는 귀납법을 활용하는 대표적인 예시인 **이진 탐색**이다. 오름차순으로 정렬된 임의의 배열이 주어질 때, 해당 배열에서 찾고자 하는 항목 $x$의 인덱스를 반환하는 알고리즘은 아래와 같다.

```jsx
function binarySearch(array, x) {
  let N = array.length,
    low = -1,
    high = N;

  // array[i-1] < x <= array[i]인 i를 반환하는 문제이다
  // 즉, 반복 루프에서 불변해야 할 요소는 다음과 같다
  // 1) 언제나 low < high 이어야 한다
  // 2) 언제나 array[low] < x <= array[high] 이어야 한다
  // highlight-start
  while (low + 1 < high) {
    // highlight-end
    let mid = (low + high) / 2;
    if (array[mid] < x) low = mid;
    else high = mid;
  }

  return high;
}
```

<br />

귀납법의 두번째 예시는 **삽입 정렬**이다. 임의의 배열이 주어질 때, 해당 배열을 오름차순 정렬하기 위한 알고리즘은 아래와 같다.

```jsx
function insertionSort(array) {
  function swap(array, i1, i2) {
    [array[i1], array[i2]] = [array[i2], array[i1]];
    return array;
  }

  for (let i = 0; i < array.length; i++) {
    // array[0..a-1]까지는 이미 정렬되어 있다면
    // array[0..a-1]에 array[i]를 끼워넣으면 된다.
    let j = i;
    while (j > 0 && array[j - 1] > array[j]) {
      swap(array, j - 1, j);
      j--;
    }
  }

  return array;
}
```

<br />

### 귀류법(Proof by Contradiction)

#### 귀류법 단계

1\. **증명하려는 사실의 반대를 가정하되, 잘못된 최적해를 올바른 형태로 바꿀 수 있음을 보인다.**  
2\. **원하는 모습으로 나열한 사실들을 언제든지 수정할 수 있음을 보인다.**  
3\. **위의 1, 2를 토대로 규칙을 정리하기**

#### 귀류법 예시

상자 형태로 된 책장을 여러 개 쌓아올리려고 할 때, 각 책장마다 버틸 수 있는 최대 무게 $M{_i}$와 책장 자신의 무게 $W{_i}$가 주어진다고 가정하면 책장을 가장 높이 쌓기 위해서는 다음을 만족해야 한다.

- $\displaystyle\sum_{j\in{above(i)}} W_{j}\le{M{_i}}$

즉, 책장 위에 올라간 다른 책장들의 무게의 합이 견딜 수 있는 최대 무게를 초과하면 안된다. 이러한 '올바른 기준'을 염두하여 단계별로 정리하면 다음과 같이 증명할 수 있다. 단, $A$가 $B$보다 더 큰 책장이라고 가정한다.($M{_A} + W{_A} > M{_B} + W{_B}$)

1\. $M{_A} > M{_B} + W{_B} - W{_A}$의 올바른 대소관계를 이룰 수 있도록 언제든지 책장 $A$와 책장 $B$의 위치를 바꿀 수 있다.

2\. 책장 $A$ 위에 올라가 있는 상자들의 무게의 합이 $X$인 상태에서 ${A}가 ${B} 위에 올라가 있다고 한다면, $M{_A} > M{_B} + W{_B} - W{_A}$에서 $M{_B} + W{_B} - W{_A} \ge {(W{_A} + X) + W{_B} - W{_A}}$이므로 다음의 대소관계도 만족해야 한다.

- $M{_A} > M{_B} + W{_B} - W{_A} \ge {(W{_A} + X) + W{_B} - W{_A}}$

3\. 위의 대소관계를 정리하여 최종적으로 다음의 대소관계가 항상 성립함이 증명된다.

- $M{_A} > X + W{_B}$

따라서 어떠한 경우의 수로 책장을 쌓더라도 얼마든지 위의 대소관계에 부합하도록 책장의 위치를 교환할 수 있으며, 가장 높이 책장을 쌓는 경우의 수를 구할 수 있다.

### 다른 기술들

#### 비둘기집의 원리

10마리의 비둘기가 한마리도 빠짐없이 9개의 비둘기집으로 나뉘어져 들어갔다면, 2마리 이상 들어간 비둘기집은 반드시 존재한다는 원리에서 시작한다.

#### 동전 뒤집기

100개의 동전이 바닥에 깔려있는데 이 중 $F$개는 앞면, 나머지 $100-F$개는 뒷면이 위로 놓여 있을 때, 반드시 한번에 $X$개의 동전을 한꺼번에 뒤집도록 하여 모든 동전들이 앞면을 위로 오게끔 하는 뒤집기 횟수의 최소값은 반드시 100인 원리에서 시작한다.

이는 비둘기집의 원리가 적용되는데, 동전을 한번에 $X$개씩 뒤집을 때마다 보이는 앞면의 개수를 종이에 적는다고 가정해본다. 그렇다면 동전을 101번 뒤집었다면 종이에 쓰인 숫자는 $F$까지 합쳐 102가 된다. 이는 종이에 쓸 수 있는 숫자 범위인 0 ~ 100에서 벗어나므로, 비둘기집의 원리에 따라 중간에 반드시 중복이 발생했다는 반증이 된다.

<br />
<br />
<br />
<br />

<text style="color:gray">_\*참고: "프로그래밍 대회에서 배우는 알고리즘 문제해결 전략"(구종만님, 인사이트)_</text>
