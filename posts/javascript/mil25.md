---
title: "재귀 이해하기"
category: javascript
path: /javascript/mil25
date: 2021-01-18 15:52:34
---

### 재귀를 통해 조합 구하기

정수로 이뤄진 배열 [1,2,3,4,5,6]에서 4개의 항목을 순서와 상관없이 고르는 경우를 생각해보자. 학창시절에 배운 수학적인 접근에 의하면 다음과 같이 조합의 경우를 생각할 수 있다.  
![combination_human](https://user-images.githubusercontent.com/67884699/105319033-9e94a400-5c07-11eb-98be-aad598111fc6.jpg)  
이를 컴퓨터가 구하도록 한다면, 첫번째 고르는 항목을 고르고나서 나머지 3개 항목을 구하는 식으로 총 4개의 중첩된 반복 루프로 구할 수도 있다. 하지만 예를 들어 매우 많은 항목들 중에서 50개를 고르는 조합의 경우를 반복 루프로 구하고자 한다면, 50개의 중첩된 루프를 직접 코드로 작성해야 할 것이다. 10개 정도의 중첩 루프를 작성할 때 쯤, 코딩하는 행위 자체를 AI에게 시킬 수 있는 방법이 간절히 생각나게 될 것이다.

놀랍게도 이렇게 무지막지해질 수 있는 반복 행위를 컴퓨터가 대신 수행하도록 하는 방법이 존재한다. 이러한 방법을 **재귀**(recursion) 알고리즘(또는 함수)라고 한다. 재귀 알고리즘의 원리를 매우 단순하게 설명하자면,

- 1\. **자가반복**을 수행해나가면서
- 2\. **콜 스택**(call stack)에 차곡차곡 자가반복의 결과를 담아가다가,
- 3\. 이러한 반복이 **기저조건**(base case)에 다다르게 되었을 때,
- 4\. 콜 스택에 담긴 데이터들을 다시 순차적(**FILO**)으로 꺼낸다.
- 5\. 이때, 하나씩 꺼내어질 때마다 미리 약속한 일련의 명령 내용에 따라 가공한다.

따라서 재귀 알고리즘을 사용하고자 할 때 가장 중요한 것은 **기저조건**을 설정하는 것이다. 위의 그림과 같이 사람들이 경우의 수를 따지기 위해 처음부터 차례대로 경우들을 생각해내는 것과 정반대로, 컴퓨터에게 재귀 알고리즘을 시키기 위해서는 **일련의 반복이 끝났을 때(=기저조건에 도달했을 때) 해당 반복동안 쌓인 데이터를 어떻게 처리할 지** 따지도록 하는 것이 중요하다. 이러한 컴퓨터 재귀 알고리즘을 그림으로 표현하면 다음과 같다.  
![combination_ai](https://user-images.githubusercontent.com/67884699/105333327-eec83200-5c18-11eb-95bf-1e1be6ea5f23.jpg)

이를 구현한 코드는 바로 아래와 같다.

```jsx{numberLines: true}
function combination(arr, m) {
  let result = [];

  // (2) 기저조건 :
  // 반복되는 재귀 호출로 m이 점점 줄어들어 1이 되면
  // 반복되는 재귀 호출로 남은 arr의 각 항목들이 각각 단일 배열로 되도록 배출한다.
  // highlight-start
  if (m === 1) return arr.map((el) => [el]);
  // highlight-end

  // (1) 재귀호출 :
  // m개를 고르기 위해 일단 i번째 항목(cur)을 골랐다면,
  // 나머지 항목들(arr.slice(i+1)) 중에서
  // m-1개를 고르기 위해 다시 항목 고르기 재귀를 호출한다.
  // 이때 재귀 호출될 항목 고르기 결과들은 기 선택된 항목(cur)에 병합될 것이다.
  arr.forEach((cur, i, array) => {
    let rest = array.slice(i + 1);
    let recursion = combination(rest, m - 1);
    let callstack = recursion.map((el) => [cur, ...el]);
    result.push(...callstack);
  });

  // 최종결과 리턴
  return result;
}

combination([1, 2, 3, 4, 5, 6], 4);
/* (15)
    [1, 2, 3, 4]
    [1, 2, 3, 5]
    [1, 2, 3, 6]
    [1, 2, 4, 5]
    [1, 2, 4, 6]
    [1, 2, 5, 6]
    [1, 3, 4, 5]
    [1, 3, 4, 6]
    [1, 3, 5, 6]
    [1, 4, 5, 6]
    [2, 3, 4, 5]
    [2, 3, 4, 6]
    [2, 3, 5, 6]
    [2, 4, 5, 6]
    [3, 4, 5, 6]
*/
```

<br />

### 재귀를 통해 순열 구하기

같은 항목이라도 순서가 다르면 별개의 경우로 간주하는 **순열**은 위의 조합에서 재귀 호출에 활용되는 대상 배열 내용만 조정하면 된다.

예를 들어 arr = [1,2,3]일 때, cur = 2이면 rest = [1, 1,2]이 되도록 설계한다. 이 경우 재귀의 기저까지 도달시켜서 배출되는 순열들은 [2,1], [2,2], [2,3]의 세가지가 될 것이다. 이러한 설계는 [1,2]와 [2,1]이 다른 선택결과로 배출될 수 있도록 돕는다. 따라서 배열 arr에서 m개의 항목을 선택하는 순열은 아래와 같이 구할 수 있다.

```jsx{numberLines:true}
function permutation(arr, m) {
  let result = [];
  if (m === 1) return arr.map((el) => [el]);

  arr.forEach((cur, i, array) => {
    // arr에서 1개를 뽑아 cur에 저장한다면
    // cur 직전까지의 항목들과 cur까지의 항목들을 병합하여 rest에 저장 및 재귀호출 대상으로 정의
    // highlight-start
    let rest = [...array.slice(0, i), ...array.slice(0, i + 1)];
    // highlight-end
    let recursion = permutation(rest, m - 1);
    let callstack = recursion.map((el) => [cur, ...el]);
    result.push(...callstack);
  });

  return result;
}

permutation([1, 2, 3, 4], 2);
/* (16)
    [1, 1]
    [2, 1]
    [2, 1]
    [2, 2]
    [3, 1]
    [3, 2]
    [3, 1]
    [3, 2]
    [3, 3]
    [4, 1]
    [4, 2]
    [4, 3]
    [4, 1]
    [4, 2]
    [4, 3]
    [4, 4]

*/
```
