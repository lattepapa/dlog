---
title: "Node.js란"
category: nodejs
path: /nodejs/nodejs01
date: 2020-10-11 14:20:00
---

### Node.js의 태동

서버를 만드는 개발도구로, 2009년 Ryan Dahl이 **비동기 입출력(Asynchronouse & Non-Blocking I/O)**의 니즈를 토대로 만들었다고 한다. 이전까지는 클라이언트(웹 환경이라면 '브라우저', 시스템 환경이라면 '프로그램')에서 데이터를 서버(웹 환경이라면 '웹 서버', 시스템 환경이라면 'OS의 파일시스템')에 어떤 요청을 보내면, 서버에서 그것을 읽고 요청에 맞는 처리(즉, '이벤트 핸들러') 후 클라이언트에게 다시 내보내기까지 클라이언트는 다른 요청을 할 수 없었다. 이를 동기 입출력이라고 한다. 동기 입출력 환경에서는 클라이언트의 대기시간이 축적됨에 따라 프로세서, 메모리 등에 필연적으로 과부하가 걸리게 된다. 이러한 문제를 해결하는 것이 바로 비동기 입출력이다. 그럼 어떻게 비동기 입출력을 구현할 수 있을까?

### Callback(콜백함수)

**콜백함수**가 바로 비동기 입출력을 구현하는 핵심 개념이라고 할 수 있다. 비동기 입출력 환경에서는 클라이언트가 서버로부터 바로 응답 받는 것이 아니라, 콜백함수에 서버의 처리 내용이 들어왔을 때에만 이 콜백함수가 클라이언트에 자동호출된다. 따라서 클라이언트는 굳이 서버의 응답을 언제까지고 기다릴 필요가 없어지게 되는 것이다. 비유를 하자면, 클라이언트에 콜백함수 따로 없는 동기 입출력 환경은 마치 등기우편(동기적 처리결과)을 기다리는 집주인(클라이언트)의 모양새이다. 반면, 클라이언트에 콜백함수가 있는 비동기 입출력 환경은 일반우편(비동기적 처리결과)이 우편함(콜백함수)에 넣어지기만 하면 되는 상황과 유사하다. 이를 코드로도 간단히 살펴볼 수 있다.

#### 동기 입출력의 경우

```jsx{numberLines: true}
const data = file.read("abc.txt");
printData(data);
// file.read 메소드를 통해 abc.txt 파일내용 출력준비가 완료될때까지 대기..
// 출력.... 지이익... 지이익....

requestTask(task);
```

<br>

#### 비동기 입출력의 경우

```jsx{numberLines: true}
file.read("abc.txt", (data) => printData(data));
requestTask(task);
// 일단 requestTask 함수가 실행되고,
// abc.txt 파일내용 출력준비가 되면 자동으로 콜백함수인 printData 실행
```

### Event Binding(이벤트 바인딩)

자바스크립트는 인터프리터(interpreter) 방식, 즉, 코드를 한 줄씩 해석해나가는 언어이다. 이는 싱글 쓰레드에 의해 코드가 연산되는 작동방식에 기인하는데, 아무리 비동기 입출력을 효과적으로 구성하더라도 성능상의 한계를 드러낼 것이 분명했다. 하지만 이는 곧 Google Chrome의 **V8 자바스크립트 엔진**을 통해 극복되었다. V8 엔진은 **node 표준 라이브러리**와 **http, socket 등의 네트워크 바인딩**을 통해 자바스크립트 코드를 네이티브 코드로 변환해준다. 또한 V8 엔진은 **이벤트 루프**와 **쓰레드 풀**를 토대로 클라이언트의 요청을 잘 받아낼 수 있도록 설계되어있다. 클라이언트의 요청이 서버와 어떻게 커뮤니케이션 되는 지 아래의 코드로 확인할 수 있다.

```jsx{numberLines: true}
http.request({ method: "POST", url: "/messages" }, (response) => {
  // [1] { event: "data" }의 경우 'chunck'에 데이터를 붙이는 콜백함수 자동호출
  let body = "";
  response
  // highlight-start
  .on("data", (chunck) => {
    body = body + chunck;
  });
  // highlight-end
  // [2] { event: "end" }의 경우, 최종 데이터를 JSON으로 다듬는 콜백함수 자동호출
  //    --> 서버에 JSON 파싱된 데이터를 저장한 후, 그 결과물을 다시 제공받음
  .on("end", () => {
    const result = JSON.parse(body)
    serverData.messages.push(result)
    response.end(JSON.stringify(result))
  })
});
```

<br>

여기서 **.on() 메소드**를 주목하자. 서버가 클라이언트로부터 데이터를 입력(POST)받는다면 **"data" 이벤트**가 발생한 것으로 간주된다. 이때 자동호출이 약속된 **콜백함수**는 서버에 입력된 데이터를 chunck로 만들어서 **비동기적으로 응답객체인 response에 실어담아 보낸다.** 이는 단순한 클라이언트의 '요청' 수준이 아니라 **어떤 이벤트를 비동기 처리(= 콜백함수)와 연계시킨 것**이라고 할 수 있는데, 이러한 연계를 바로 **바인딩(bindng)**이라고 한다. 이벤트 바인딩은 앞서 살펴 본 코드처럼 `{객체}.on("이벤트명", (인자) => {익명콜백함수})`의 형식으로 지정하면 된다.

### Modularization(모듈화)

Node.js는 필요한 기능 및 코드들을 별도의 자바스크립트 파일로 모듈화하여 관리하는 것을 지원한다. 단, CommonJs 표준스펙을 따라야하는 제약조건이 있다. 모듈로 분리된 자바스크립트 파일을 사용하고자 할 때에는 **require() 함수**로 호출하면 된다. 이 함수는 해당 자바스크립트 파일을 자바스크립트 객체로 인식시키는 역할을 수행한다. 만약 여러 개의 모듈을 합쳐서 하나의 패키지로 만든다면, 다른 Node.js 개발자들도 사용할 있도록 npm에 의한 설치 공유도 가능하다.

<br>
<br>
<br>

<text style="color:gray">_\*참고: "Node.js 프로그래밍"(정재곤님, 이지스퍼블리싱)_</text>
