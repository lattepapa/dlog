{"componentChunkName":"component---src-templates-post-template-tsx","path":"/BFS(너비우선탐색)","result":{"pageContext":{"html":"<h4>문제</h4>\n<p>값이 Number 타입인 value와, 값이 배열인 children을 속성으로 갖는 Node 객체를 입력받아, 너비우선탐색이 수행된 순서대로 value들을 배열에 저장하여 리턴하라.</p>\n<h4>입출력 예시</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let Node = value =&gt; {\n  this.value = value;\n  this.children = [];\n};\nNode.prototype.addChild = child =&gt; {\n  this.children.push(child);\n  return child;\n};\n\nlet root = new Node(1);\nlet rootChild1 = root.addChild(new Node(2));\nlet rootChild2 = root.addChild(new Node(3));\nlet leaf1 = rootChild1.addChild(new Node(4));\nlet leaf2 = rootChild1.addChild(new Node(5));\nleaf1.addChild(new Node(6));\nrootChild2.addChild(new Node(7));\nconsole.log((dfs(root)))\n// [ 1, 2, 3, 4, 5, 7, 6 ]</code></pre></div>\n<br>\n<h4>Reference</h4>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">treeBfs</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">node</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 각 정점들의 부모들만 큐에 저장하여, 이들의 value들을 차례대로 빈 배열에 저장할 것이다.</span>\n  <span class=\"token keyword\">let</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> values <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token comment\">// 위에서 설계한대로, 각 정점들의 부모들(head)의 value들만 차례대로 빈 배열에 저장한다.</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">let</span> head <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">    queue <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">    values<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>head<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>    head<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>\n      <span class=\"token punctuation\">(</span><span class=\"token parameter\">child</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n<span class=\"gatsby-highlight-code-line\">        <span class=\"token comment\">// 자식 정점들 중 또다시 부모들만 따기 위해 큐에 다음 순서로 밀어넣는다.</span></span><span class=\"gatsby-highlight-code-line\">        queue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span></span>    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> values<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<br>\n<p>일반적으로 BFS(너비우선탐색) 또한 직전 포스팅에서 살펴본 DFS와 마찬가지로 모든 정점(vertex)에 대한 조회를 감행한다. 따라서 시간복잡도 역시 DFS와 동일하게, 최소 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N+E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>의 시간복잡도(<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>: 정점의 수, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>: 간선의 수)를 갖으며, 인접행렬의 경우 최소 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><msup><mrow></mrow><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N{^2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\"><span class=\"mord\"><span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>가 된다.</p>\n<p>단, BFS가 DFS와 다른 것은 위의 코드에서 볼 수 있듯이 탐색 로직이 직관적이지 않고 복잡성을 갖는다. 또한, 처음부터 트리의 최대 깊이까지 순회하지 않고 정점과 인접한 곳부터 탐색한다. 이러한 원리는 BFS가 '최단경로' 탐색과 같은 길찾기 원리에 활용될 수 있음을 시사한다.</p>","title":"BFS(너비우선탐색)","category":"algorithm","date":"02 Jan, 2021"}},"staticQueryHashes":["3649515864"]}