{"componentChunkName":"component---src-templates-post-template-tsx","path":"/DFS(깊이우선탐색)","result":{"pageContext":{"html":"<h4>문제</h4>\n<p>값이 Number 타입인 value와, 값이 배열인 children을 속성으로 갖는 Node 객체를 입력받아, 깊이우선탐색이 수행된 순서대로 value들을 배열에 저장하여 리턴하라.</p>\n<h4>입출력 예시</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let Node = value =&gt; {\n  this.value = value;\n  this.children = [];\n};\nNode.prototype.addChild = child =&gt; {\n  this.children.push(child);\n  return child;\n};\n\nlet root = new Node(1);\nlet rootChild1 = root.addChild(new Node(2));\nlet rootChild2 = root.addChild(new Node(3));\nlet leaf1 = rootChild1.addChild(new Node(4));\nlet leaf2 = rootChild1.addChild(new Node(5));\nleaf1.addChild(new Node(6));\nrootChild2.addChild(new Node(7));\nconsole.log((dfs(root)))\n// [ 1, 2, 4, 6, 5, 3, 7 ]</code></pre></div>\n<br>\n<h4>Reference</h4>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">treeDfs</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">node</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> values <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  node<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>\n    <span class=\"token punctuation\">(</span><span class=\"token parameter\">child</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span>\n<span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">(</span>values <span class=\"token operator\">=</span> values<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></span>  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> values<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<br>\n<p>일반적으로 DFS(깊이우선탐색)은 모든 정점(vertex)에 대한 조회를 감행하므로, 최소 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N+E)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mclose\">)</span></span></span></span>의 시간복잡도(<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span>: 정점의 수, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>E</mi></mrow><annotation encoding=\"application/x-tex\">E</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span></span></span>: 간선의 수)를 갖는다. 만약 이마저도 연결리스트가 아니라 <strong>인접행렬</strong>로 DFS를 구현한다면, 시간복잡도는 최소 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><msup><mrow></mrow><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N{^2})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord\"><span class=\"mord\"><span></span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>가 된다. 다행히도, 이번 포스팅 문제에 의하면 DFS는 <strong>Binary Tree</strong>(이진트리)에 대해 수행된다. Binary Tree는 Graph(그래프)의 하나이며, 연결리스트의 친척이라고 할 수 있다.</p>","title":"DFS(깊이우선탐색)","category":"algorithm","date":"02 Jan, 2021"}},"staticQueryHashes":["3649515864"]}