{"componentChunkName":"component---src-templates-post-template-tsx","path":"/HTTP","result":{"pageContext":{"html":"<blockquote>\n<p><em>'an application-layer protocol for transmitting hypermedia documents, such as HTML. It was designed for communication between web browsers and web servers'</em> - <strong>MDN</strong></p>\n</blockquote>\n<p><strong>웹 서버</strong>로부터 <strong>HTML 문서</strong>를 거둬들여서(<strong>fetch</strong>), <strong>웹 브라우저</strong>로 <strong>HTML 문서</strong>를 전달해주기 위한(<strong>transmit</strong>), <strong>어플리케이션 계층</strong>의 통신규약을 의미한다.</p>\n<h4>HTTP의 2가지 특징</h4>\n<p>1) <strong>Stateless</strong> : 클라이언트(browser)의 요청에 대해 서버가 응답하면 연결(=맥락)이 종료된다. 즉, 앞선 클라이언트-서버 간 교신이 GET이었는지 POST였는지, 어떤 메소드의 교신이었는지는 현재 교신에서는 전혀 알 수 없다. 단, 만약 쿠키가 있다면, 교신들 간 맥락 파악이 가능해진다.<br>\n2) <strong>Connectionless</strong> : 서버는 한번의 요청에 대해 한번의 응답만 한다. 다시말해 클라이언트의 요청에 대한 서버의 응답이 이뤄지면 해당 교신은 바로 종료된다. 한번의 교신에 다수의 요청과 응답이 이뤄질 수는 없다.</p>\n<h4>TLS(encrypted TCP)</h4>\n<p>HTTP 통신 상에서 단순히 텍스트 정보만 다루는 것에서 나아가, 이미지, 영상 등의 전송을 가능하게 한 통신규약</p>\n<h4>브라우저(Browser)</h4>\n<p>브라우저는 HTTP 환경에서 모든 클라이언트 <strong>요청(Request)의 시작점</strong>이다.</p>\n<h4>RPC(Remote Procedure Call)</h4>\n<p>클라이언트(browser)가 서버(원격지)에 요청하는 그 자체를 의미</p>\n<h4>서버(Server)</h4>\n<p>서버는 클라이언트(browser)의 요청에 따라 다시 클라이언트에 HTTP 서비스를 <strong>제공(Response)</strong>한다.</p>\n<h4>프록시(Proxy)</h4>\n<p>클라이언트 앞단에서 Caching, Filtering, LB, Authentication, Logging의 기능을 수행</p>\n<h4>URL(Uniform Resource Locator)</h4>\n<p>쉽게 말해 웹 주소를 의미한다.</p>\n<h4>URL의 구조</h4>\n<p>예를 들어 <a href=\"https://www.google.com/search?q=cats#p2\">https://www.google.com/search?q=cats#p2</a> 라는 URL이 있다면<br>\n1) <strong>scheme</strong> : 'http', 'https', 'ssh', 'git' 등<br>\n2) <strong>host</strong> : 'google.com', 'localhost', '192.168.35.82' 등<br>\n3) <strong>sub domain</strong> : 'www', 'mail', 'blog' 등<br>\n4) <strong>path</strong> : 'search', 'about.html', 'blog/entries/2/big-day' 등<br>\n5) <strong>query string</strong> : 'q=cats&#x26;ref=mobile&#x26;page=4' 등<br>\n6) <strong>hash fragment</strong> : 'p2', 'FAQ', '/profile/edit' 등\n<br>\n<br>\n<br></p>\n<h3>HTTP 흐름</h3>\n<h4>1. TCP 연결 활성화</h4>\n<p>클라이언트(browser)가 서버로 HTTP 서비스를 요청함으로써 TCP 연결이 활성화 된다.</p>\n<h4>2. HTTP 메시지 전송</h4>\n<p>다음과 같은 헤더(header)를 필두로 하여 클라이언트(browser)가 서버로 메시지를 전송한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">GET / HTTP/1.1 Host: developer.mozilla.org Accept-Language: fr</code></pre></div>\n<h4>3. 서버로부터 회신 받은 내용 읽기</h4>\n<p>다음과 같은 HTML 문서로써 서버가 메시지를 응답한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">HTTP/1.1 200 OK\nDate: Sat, 09 Oct 2010 14:28:02 GMT\nServer: Apache\nLast-Modified: Tue, 01 Dec 2009 20:18:22 GMT\nETag: \"51142bc1-7449-479b075b2891b\"\nAccept-Ranges: bytes\nContent-Length: 29769\nContent-Type: text/html\n\n&lt;!DOCTYPE html... (here comes the 29769 bytes of the requested web page)</code></pre></div>\n<h4>4. 커뮤니케이션 종료</h4>\n<br>\n<br>\n<br>\n<h3>AJAX(Asynchronous Javascript and XML)</h3>\n<h4>API(Application Programming Interface)</h4>\n<p>클라이언트(browser)가 서버의 자원을 이용할 수 있도록 마련된 인터페이스, 즉, <strong>메소드</strong>를 의미한다.</p>\n<h4>XHR(XMLHttpRequest)</h4>\n<p>클라이언트(browser)가 서버와 상호 작용하기 위해 사용하는 <strong>객체</strong>를 의미한다. XHR은 웹페이지의 모든 요소를 한번에 불러오는 것이 아니라 비동기적으로 불러오는 것에 활용된다. 이 덕분에 전체 페이지 정보를 매번 한꺼번에 렌더링할 필요가 없어지게 되었다.</p>\n<h4>주요 메소드(RESTful APIs)</h4>\n<p>1) <strong>GET</strong> /? : 서버에 메시지(자원)을 <strong>요청</strong>하는 메소드 → <em>domain.com/api/users</em><br>\n2) <strong>POST</strong> /? : 서버에 메시지(자원)을 <strong>생성</strong>하는 메소드 → <em>domain.com/api/users</em><br>\n3) <strong>PUT</strong> /? : 서버의 메시지(자원)의 속성을 <strong>대체수정</strong>하는 메소드 → <em>domain.com/api/users/{username}</em><br>\n4) <strong>PATCH</strong> /? : 서버의 메시지(자원)의 속성을 <strong>일부수정</strong>하는 메소드 → <em>domain.com/api/users/{username}</em><br>\n5) <strong>DELETE</strong> /? : 서버의 메시지(자원)의 속성을 <strong>삭제</strong>하는 메소드 → <em>domain.com/api/users/{username}</em></p>\n<h4>메소드별 HTTP 응답코드</h4>\n<p>1) <strong>1xx</strong> : \"Hold on..\"<br>\n2) <strong>2xx</strong> : \"Here you go 🙂\"<br>\n3) <strong>3xx</strong> : \"Your request will be redirected to target page!\"</p>\n<ul>\n<li>304 : \"요청에 대한 응답이 아직 수정되지 않았고 caching된 내용만 있음\"</li>\n</ul>\n<p>4) <strong>4xx</strong> : \"YOU screwed up! ☹️\"</p>\n<ul>\n<li>403 : \"컨텐츠에 접근할 권한이 없음\"</li>\n<li>404 : \"요청받은 리소스를 사용할 수 없음\"</li>\n</ul>\n<p>5) <strong>5xx</strong> : \"I screwed up, sorry....\"</p>\n<ul>\n<li>500 : \"서버가 처리할 수 없는 요청임\"</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token comment\">// XHR API를 활용한 서버와의 통신</span>\n<span class=\"token keyword\">var</span> xhr <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'get'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'http://52.78.213.9:3000/messages'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nxhr<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onreadystatechange</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">!==</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// readyState 4: 완료</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>xhr<span class=\"token punctuation\">.</span>resonseText<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'에러: '</span> <span class=\"token operator\">+</span> xhr<span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nxhr<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 요청 전송</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<br>\n<p>보다시피 XHR은 간단한 구문도 조금 복잡해보이는 경향이 있다. 그렇기 때문에 이러한 메소드를 조금 더 간소화 시킨 라이브러리가 등장하게 되었다. 바로 <strong>jQuery</strong>이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token comment\">// jQuery 라이브러리를 활용한 서버와의 통신</span>\n$<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"http://52.78.213.9:3000/messages\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// response: 서버로부터 온 응답</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<br>\n<p>그런데 이 jQuery도 인간의 관점에서 난해하다는 의견이 나오기 시작했다. 따라서 마치 javascript를 그대로 쓰는 것 같은 API가 나오게 되었다. 바로 <strong>가독성</strong>의 <strong>fetch()</strong> 구문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token comment\">// fetch API를 활용한 서버와의 통신</span>\n<span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'http://52.78.213.9:3000/messages'</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">response</span> <span class=\"token operator\">=></span> response<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">json</span> <span class=\"token operator\">=></span> <span class=\"token comment\">// 서버로부터 json 형태로 전달받은 응답(즉, 콜백))</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<br>\n<h4>AJAX</h4>\n<p><strong>XHR</strong>을 통해 서버와 자유롭게 통신할 수 있으면서, <strong>DOM</strong>을 활용하여 Seamless하게 페이지의 <strong>일부 부분만 렌더링</strong>이 가능하도록 Dynamic Web Page(App)를 구현하기 위한 비동기 객체이다. 사실상 jQuery를 위한 라이브러리 역할을 수행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token comment\">// jQuery AJAX chaining</span>\n$<span class=\"token punctuation\">.</span><span class=\"token function\">ajax</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n\turl<span class=\"token operator\">:</span> <span class=\"token string\">'http://52.78.213.9:3000/messages'</span><span class=\"token punctuation\">,</span>\n\tmethod<span class=\"token operator\">:</span> <span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span>\n\tdataType<span class=\"token operator\">:</span> <span class=\"token string\">'json'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token function\">done</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">json</span> <span class=\"token operator\">=></span> <span class=\"token comment\">// 서버로부터 json 형태로 전달받은 응답(즉, 콜백))</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token function\">fail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">xhr<span class=\"token punctuation\">,</span> status<span class=\"token punctuation\">,</span> errorThrown</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">throw</span> error<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">.</span><span class=\"token function\">always</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">xhr<span class=\"token punctuation\">,</span> status</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'요청완료'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>","title":"HTTP","category":"javascript","date":"23 Sep, 2020"}},"staticQueryHashes":["3649515864"]}