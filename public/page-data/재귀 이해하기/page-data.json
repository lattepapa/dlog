{"componentChunkName":"component---src-templates-post-template-tsx","path":"/재귀 이해하기","result":{"pageContext":{"html":"<h3>재귀를 통해 조합 구하기</h3>\n<p>정수로 이뤄진 배열 [1,2,3,4,5,6]에서 4개의 항목을 순서와 상관없이 고르는 경우를 생각해보자. 학창시절에 배운 수학적인 접근에 의하면 다음과 같이 조합의 경우를 생각할 수 있다.<br>\n<img src=\"https://user-images.githubusercontent.com/67884699/105319033-9e94a400-5c07-11eb-98be-aad598111fc6.jpg\" alt=\"combination_human\"><br>\n이를 컴퓨터가 구하도록 한다면, 첫번째 고르는 항목을 고르고나서 나머지 3개 항목을 구하는 식으로 총 4개의 중첩된 반복 루프로 구할 수도 있다. 하지만 예를 들어 매우 많은 항목들 중에서 50개를 고르는 조합의 경우를 반복 루프로 구하고자 한다면, 50개의 중첩된 루프를 직접 코드로 작성해야 할 것이다. 10개 정도의 중첩 루프를 작성할 때 쯤, 코딩하는 행위 자체를 AI에게 시킬 수 있는 방법이 간절히 생각나게 될 것이다.</p>\n<p>놀랍게도 이렇게 무지막지해질 수 있는 반복 행위를 컴퓨터가 대신 수행하도록 하는 방법이 존재한다. 이러한 방법을 <strong>재귀</strong>(recursion) 알고리즘(또는 함수)라고 한다. 재귀 알고리즘의 원리를 매우 단순하게 설명하자면,</p>\n<ul>\n<li>1. <strong>자가반복</strong>을 수행해나가면서</li>\n<li>2. <strong>콜 스택</strong>(call stack)에 차곡차곡 자가반복의 결과를 담아가다가,</li>\n<li>3. 이러한 반복이 <strong>기저조건</strong>(base case)에 다다르게 되었을 때,</li>\n<li>4. 콜 스택에 담긴 데이터들을 다시 순차적(<strong>FILO</strong>)으로 꺼낸다.</li>\n<li>5. 이때, 하나씩 꺼내어질 때마다 미리 약속한 일련의 명령 내용에 따라 가공한다.</li>\n</ul>\n<p>따라서 재귀 알고리즘을 사용하고자 할 때 가장 중요한 것은 <strong>기저조건</strong>을 설정하는 것이다. 위의 그림과 같이 사람들이 경우의 수를 따지기 위해 처음부터 차례대로 경우들을 생각해내는 것과 정반대로, 컴퓨터에게 재귀 알고리즘을 시키기 위해서는 <strong>일련의 반복이 끝났을 때(=기저조건에 도달했을 때) 해당 반복동안 쌓인 데이터를 어떻게 처리할 지</strong> 따지도록 하는 것이 중요하다. 이러한 컴퓨터 재귀 알고리즘을 그림으로 표현하면 다음과 같다.<br>\n<img src=\"https://user-images.githubusercontent.com/67884699/105333327-eec83200-5c18-11eb-95bf-1e1be6ea5f23.jpg\" alt=\"combination_ai\"></p>\n<p>이를 구현한 코드는 바로 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">combination</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> m</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// (2) 기저조건 :</span>\n  <span class=\"token comment\">// 반복되는 재귀 호출로 m이 점점 줄어들어 1이 되면</span>\n  <span class=\"token comment\">// 반복되는 재귀 호출로 남은 arr의 각 항목들이 각각 단일 배열로 되도록 배출한다.</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>el<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token comment\">// (1) 재귀호출 :</span>\n  <span class=\"token comment\">// m개를 고르기 위해 일단 i번째 항목(cur)을 골랐다면,</span>\n  <span class=\"token comment\">// 나머지 항목들(arr.slice(i+1)) 중에서</span>\n  <span class=\"token comment\">// m-1개를 고르기 위해 다시 항목 고르기 재귀를 호출한다.</span>\n  <span class=\"token comment\">// 이때 재귀 호출될 항목 고르기 결과들은 기 선택된 항목(cur)에 병합될 것이다.</span>\n  arr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cur<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> array</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> rest <span class=\"token operator\">=</span> array<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> recursion <span class=\"token operator\">=</span> <span class=\"token function\">combination</span><span class=\"token punctuation\">(</span>rest<span class=\"token punctuation\">,</span> m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> callstack <span class=\"token operator\">=</span> recursion<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>el<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>callstack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 최종결과 리턴</span>\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">combination</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/* (15)</span>\n<span class=\"token comment\">    [1, 2, 3, 4]</span>\n<span class=\"token comment\">    [1, 2, 3, 5]</span>\n<span class=\"token comment\">    [1, 2, 3, 6]</span>\n<span class=\"token comment\">    [1, 2, 4, 5]</span>\n<span class=\"token comment\">    [1, 2, 4, 6]</span>\n<span class=\"token comment\">    [1, 2, 5, 6]</span>\n<span class=\"token comment\">    [1, 3, 4, 5]</span>\n<span class=\"token comment\">    [1, 3, 4, 6]</span>\n<span class=\"token comment\">    [1, 3, 5, 6]</span>\n<span class=\"token comment\">    [1, 4, 5, 6]</span>\n<span class=\"token comment\">    [2, 3, 4, 5]</span>\n<span class=\"token comment\">    [2, 3, 4, 6]</span>\n<span class=\"token comment\">    [2, 3, 5, 6]</span>\n<span class=\"token comment\">    [2, 4, 5, 6]</span>\n<span class=\"token comment\">    [3, 4, 5, 6]</span>\n<span class=\"token comment\">*/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<br />\n<h3>재귀를 통해 순열 구하기</h3>\n<p>같은 항목이라도 순서가 다르면 별개의 경우로 간주하는 <strong>순열</strong>은 위의 조합에서 재귀 호출에 활용되는 대상 배열 내용만 조정하면 된다.</p>\n<p>예를 들어 arr = [1,2,3]일 때, cur = 2이면 rest = [1, 1,2]이 되도록 설계한다. 이 경우 재귀의 기저까지 도달시켜서 배출되는 순열들은 [2,1], [2,2], [2,3]의 세가지가 될 것이다. 이러한 설계는 [1,2]와 [2,1]이 다른 선택결과로 배출될 수 있도록 돕는다. 따라서 배열 arr에서 m개의 항목을 선택하는 순열은 아래와 같이 구할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">permutation</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> m</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>el<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  arr<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">cur<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> array</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// arr에서 1개를 뽑아 cur에 저장한다면</span>\n    <span class=\"token comment\">// cur 직전까지의 항목들과 cur까지의 항목들을 병합하여 rest에 저장 및 재귀호출 대상으로 정의</span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">let</span> rest <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>array<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>array<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></span>    <span class=\"token keyword\">let</span> recursion <span class=\"token operator\">=</span> <span class=\"token function\">permutation</span><span class=\"token punctuation\">(</span>rest<span class=\"token punctuation\">,</span> m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> callstack <span class=\"token operator\">=</span> recursion<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>el<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>callstack<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">permutation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/* (16)</span>\n<span class=\"token comment\">    [1, 1]</span>\n<span class=\"token comment\">    [2, 1]</span>\n<span class=\"token comment\">    [2, 1]</span>\n<span class=\"token comment\">    [2, 2]</span>\n<span class=\"token comment\">    [3, 1]</span>\n<span class=\"token comment\">    [3, 2]</span>\n<span class=\"token comment\">    [3, 1]</span>\n<span class=\"token comment\">    [3, 2]</span>\n<span class=\"token comment\">    [3, 3]</span>\n<span class=\"token comment\">    [4, 1]</span>\n<span class=\"token comment\">    [4, 2]</span>\n<span class=\"token comment\">    [4, 3]</span>\n<span class=\"token comment\">    [4, 1]</span>\n<span class=\"token comment\">    [4, 2]</span>\n<span class=\"token comment\">    [4, 3]</span>\n<span class=\"token comment\">    [4, 4]</span>\n<span class=\"token comment\"></span>\n<span class=\"token comment\">*/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<br />\n<h3>재귀를 통해 항목들을 조합하기</h3>\n<p>서로 다른 양의 정수들로 이뤄진 배열의 항목들을 조합해서 만들 수 있는 모든 경우의 수를 생각해보자. 예를 들어 배열 [1,7]의 각 항목들을 조합하면 1, 17, 71, 7을 만들어낼 수 있다. 이처럼, <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>개의 숫자로 만들 수 있는 모든 경우의 수는</p>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle scriptlevel=\"0\" displaystyle=\"true\"><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mrow></mrow><mi>n</mi></msub><mi>P</mi><msub><mrow></mrow><mi>k</mi></msub></mstyle></mrow><annotation encoding=\"application/x-tex\">\\displaystyle\\sum_{k=1}^n {_n}P{_k}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:2.9535100000000005em;vertical-align:-1.302113em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.6513970000000002em;\"><span style=\"top:-1.8478869999999998em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.0500049999999996em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.300005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.302113em;\"><span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\"><span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord\"><span class=\"mord\"><span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n<p>를 만족한다. 이는 최대 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>자리부터 최소 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>자리의 수를 만들기 위한 모든 경우의 수를 구하는 것을 의미하는데, 만약 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span> 자리의 수를 만들어본다고 가정하자. 처음 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>번째 자리에 들어갈 수 있는 수는 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span>개가 될 것이다. 그 다음 자리에는 앞서 선택한 수를 제외한 나머지 숫자들 중 하나가 들어갈 수 있다. 그리고 또 그 다음 자리에는 앞서 선택한 수를 제외한 나머지 숫자들 중 하나가 들어갈 수 있다.</p>\n<p>사람이 이러한 작업을 한다고 하면 매우 고된 일이 될 것이다. 만약 [1,2,3,4]을 가지고 만들 수 있는 모든 경우의 수를 생각한다면 서로 다른 숫자조합이 64가지나 나온다. 하지만 지금까지 돌아본 것처럼, 재귀 알고리즘을 활용하면 매우 빠르고 간단하게 모든 경우의 수들을 헤아릴 수 있다. 주어진 배열의 길이만큼 순회하면서, 해당 인덱스를 제외한 나머지 항목들을 대상으로 숫자를 결합해나가면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre style=\"counter-reset: linenumber 0\" class=\"language-jsx line-numbers\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">caseOfNum</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 헬퍼함수이자 재귀 알고리즘</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">recursion</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">arr<span class=\"token punctuation\">,</span> str</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 집합(Set)은 중복을 제거하여 항목을 저장해준다.</span>\n    <span class=\"token keyword\">let</span> set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// (1) 재귀호출 :</span>\n    <span class=\"token comment\">// 주어진 배열에서 i번째 항목을 골랐을 때</span>\n    <span class=\"token comment\">// 그것을 제외한 나머지 항목들에 대해 차례대로 빈문자열과 함하여</span>\n    <span class=\"token comment\">// 숫자조합들을 완성해나간다.</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// spread 연산자는 항목들을 손쉽게 배열에 배치해준다.</span>\n      <span class=\"token keyword\">let</span> rest <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span>arr<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      rest<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">recursion</span><span class=\"token punctuation\">(</span>rest<span class=\"token punctuation\">,</span> str <span class=\"token operator\">+</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// (2) 기저조건 :</span>\n    <span class=\"token comment\">// 재귀호출들을 통해 숫자들을 합쳐나가야 했을텐데 그럼에도 불구하고</span>\n    <span class=\"token comment\">// 최종 숫자조합이 존재하지 않는다면 집합에 삽입하지 않는다.</span>\n    <span class=\"token comment\">// 존재하는 숫자조합만 중복제거하여 집합에 담고</span>\n    <span class=\"token comment\">// 집합을 배열로 변환 후 result의 항목으로 전개삽입한다.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>str <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token function\">Number</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>set<span class=\"token punctuation\">.</span>size <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>Array<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">recursion</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> <span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">caseOfNum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/*  (64) \n[1234, 123, 1243, 124, 12, 1324, 132, 1342, 134, 13, 1423, 142, 1432, 143, 14, 1, 2134, 213, 2143, 214, 21, 2314, 231, 2341, 234, 23, 2413, 241, 2431, 243, 24, 2, 3124, 312, 3142, 314, 31, 3214, 321, 3241, 324, 32, 3412, 341, 3421, 342, 34, 3, 4123, 412, 4132, 413, 41, 4213, 421, 4231, 423, 42, 4312, 431, 4321, 432, 43, 4]\n*/</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<br />\n<p>위의 알고리즘을 활용하여 [1,7]로 만들 수 있는 숫자 조합을 구한 그림은 다음과 같다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/67884699/105573515-8193d880-5da1-11eb-860b-4cda0c4adfd4.jpg\" alt=\"caseOfNum\"></p>","title":"재귀 이해하기","category":"javascript","date":"18 Jan, 2021"}},"staticQueryHashes":["3649515864"]}